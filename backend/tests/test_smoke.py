"""
How to run:
    # Option 1: Local (requires Python dependencies)
    cd backend
    python -m pytest tests/test_smoke.py -v
    
    # Option 2: Docker (recommended)
    docker-compose exec backend python -m pytest tests/test_smoke.py -v
    
    # Option 3: Docker run (if compose not running)
    docker run --rm -v $(pwd)/backend:/app -w /app python:3.11-slim bash -c "pip install -r requirements.txt && python -m pytest tests/test_smoke.py -v"
    
    # Option 4: Run in existing container
    docker exec -it smart-offertgenerator-backend-1 python -m pytest tests/test_smoke.py -v
"""

import pytest
from fastapi.testclient import TestClient
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from app.main import app
from app.db import get_db, Base
from app.models import User, Company, ProjectRequirements, Quote, QuoteItem
from app.schemas import CreateProjectRequirementsRequest, CreateQuoteRequest
import json

# Test database setup
SQLALCHEMY_DATABASE_URL = "sqlite:///./test.db"
engine = create_engine(SQLALCHEMY_DATABASE_URL, connect_args={"check_same_thread": False})
TestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

def override_get_db():
    try:
        db = TestingSessionLocal()
        yield db
    finally:
        db.close()

app.dependency_overrides[get_db] = override_get_db

@pytest.fixture(scope="function")
def db_session():
    """Create a fresh database for each test"""
    Base.metadata.create_all(bind=engine)
    db = TestingSessionLocal()
    try:
        yield db
    finally:
        db.close()
        Base.metadata.drop_all(bind=engine)

@pytest.fixture(scope="function")
def test_client():
    """Create test client"""
    return TestClient(app)

@pytest.fixture(scope="function")
def test_user(db_session):
    """Create test user and company"""
    company = Company(
        name="Test Company",
        email="test@company.com",
        phone="123456789"
    )
    db_session.add(company)
    db_session.commit()
    
    user = User(
        email="test@example.com",
        hashed_password="hashed_password",
        company_id=company.id,
        is_active=True
    )
    db_session.add(user)
    db_session.commit()
    
    return user

@pytest.fixture(scope="function")
def auth_headers(test_user):
    """Create auth headers for test user"""
    return {"Authorization": f"Bearer test_token_{test_user.id}"}

class TestSmokeWorkflow:
    """End-to-end smoke test for the complete quote workflow"""
    
    def test_complete_quote_workflow(self, test_client, db_session, test_user, auth_headers):
        """
        Test the complete workflow:
        1. Create project requirements
        2. Autogenerate quote
        3. Create quote
        4. Send quote (stub)
        5. Public GET quote
        6. Accept quote
        """
        
        # Step 1: Create project requirements
        requirements_data = CreateProjectRequirementsRequest(
            project_name="Smoke Test Project",
            customer_name="Smoke Test Customer",
            customer_email="customer@test.com",
            description="Test project for smoke testing",
            budget_range="10000-50000",
            timeline="3 months",
            requirements=["Requirement 1", "Requirement 2"]
        )
        
        response = test_client.post(
            "/api/project-requirements/",
            json=requirements_data.dict(),
            headers=auth_headers
        )
        assert response.status_code == 200
        requirements = response.json()
        requirements_id = requirements["id"]
        
        print(f"‚úÖ Created project requirements: {requirements_id}")
        
        # Step 2: Autogenerate quote
        autogen_data = {
            "requirements_id": requirements_id,
            "company_id": test_user.company_id
        }
        
        response = test_client.post(
            "/api/quotes/autogenerate/",
            json=autogen_data,
            headers=auth_headers
        )
        assert response.status_code == 200
        autogen_result = response.json()
        
        print(f"‚úÖ Autogenerated quote structure: {autogen_result}")
        
        # Step 3: Create quote
        quote_data = CreateQuoteRequest(
            project_requirements_id=requirements_id,
            customer_name="Smoke Test Customer",
            project_name="Smoke Test Project",
            items=[
                {
                    "description": "Test Item 1",
                    "quantity": 1,
                    "unit_price": 1000.0,
                    "kind": "labor"
                },
                {
                    "description": "Test Item 2", 
                    "quantity": 2,
                    "unit_price": 500.0,
                    "kind": "material"
                }
            ]
        )
        
        response = test_client.post(
            "/api/quotes/",
            json=quote_data.dict(),
            headers=auth_headers
        )
        assert response.status_code == 200
        quote = response.json()
        quote_id = quote["id"]
        
        print(f"‚úÖ Created quote: {quote_id}")
        
        # Step 4: Send quote (stub - just verify endpoint exists)
        response = test_client.post(
            f"/api/quotes/{quote_id}/send/",
            json={"email": "customer@test.com"},
            headers=auth_headers
        )
        # Note: This might be a stub in test environment
        assert response.status_code in [200, 201, 422]  # Allow various success codes
        
        print(f"‚úÖ Quote send endpoint responded: {response.status_code}")
        
        # Step 5: Get quote details
        response = test_client.get(
            f"/api/quotes/{quote_id}",
            headers=auth_headers
        )
        assert response.status_code == 200
        quote_details = response.json()
        assert quote_details["id"] == quote_id
        assert quote_details["customer_name"] == "Smoke Test Customer"
        
        print(f"‚úÖ Retrieved quote details: {quote_details['id']}")
        
        # Step 6: Get public quote (if public token exists)
        if "public_token" in quote_details:
            public_token = quote_details["public_token"]
            
            response = test_client.get(f"/api/public/quotes/{public_token}")
            assert response.status_code == 200
            public_quote = response.json()
            assert public_quote["id"] == quote_id
            
            print(f"‚úÖ Retrieved public quote: {public_quote['id']}")
            
            # Step 7: Accept quote (stub - just verify endpoint exists)
            response = test_client.post(f"/api/public/quotes/{public_token}/accept")
            # Note: This might be a stub in test environment
            assert response.status_code in [200, 201, 422]  # Allow various success codes
            
            print(f"‚úÖ Quote accept endpoint responded: {response.status_code}")
        else:
            print("‚ö†Ô∏è  No public token found, skipping public quote tests")
        
        print("üéâ Complete smoke test workflow passed!")
    
    def test_quote_calculation(self, test_client, db_session, test_user, auth_headers):
        """Test quote calculation endpoint"""
        
        # Create minimal quote data for calculation
        calc_data = {
            "items": [
                {
                    "description": "Test Item",
                    "quantity": 2,
                    "unit_price": 100.0,
                    "kind": "labor"
                }
            ]
        }
        
        response = test_client.post(
            "/api/quotes/calc/",
            json=calc_data,
            headers=auth_headers
        )
        assert response.status_code == 200
        calc_result = response.json()
        
        # Verify calculation
        assert "total" in calc_result
        assert "subtotal" in calc_result
        assert calc_result["subtotal"] == 200.0  # 2 * 100
        
        print(f"‚úÖ Quote calculation test passed: {calc_result}")
    
    def test_quote_pdf_generation(self, test_client, db_session, test_user, auth_headers):
        """Test PDF generation endpoint"""
        
        # First create a quote
        requirements_data = CreateProjectRequirementsRequest(
            project_name="PDF Test Project",
            customer_name="PDF Test Customer",
            customer_email="pdf@test.com",
            description="Test project for PDF generation",
            budget_range="5000-10000",
            timeline="1 month",
            requirements=["PDF requirement"]
        )
        
        response = test_client.post(
            "/api/project-requirements/",
            json=requirements_data.dict(),
            headers=auth_headers
        )
        assert response.status_code == 200
        requirements_id = response.json()["id"]
        
        quote_data = CreateQuoteRequest(
            project_requirements_id=requirements_id,
            customer_name="PDF Test Customer",
            project_name="PDF Test Project",
            items=[
                {
                    "description": "PDF Test Item",
                    "quantity": 1,
                    "unit_price": 1000.0,
                    "kind": "labor"
                }
            ]
        )
        
        response = test_client.post(
            "/api/quotes/",
            json=quote_data.dict(),
            headers=auth_headers
        )
        assert response.status_code == 200
        quote_id = response.json()["id"]
        
        # Test PDF generation
        response = test_client.get(
            f"/api/quotes/{quote_id}/pdf/",
            headers=auth_headers
        )
        # PDF endpoint should return PDF content or redirect
        assert response.status_code in [200, 302, 201]
        
        print(f"‚úÖ PDF generation test passed for quote: {quote_id}")

if __name__ == "__main__":
    # Run smoke tests directly
    pytest.main([__file__, "-v"])
